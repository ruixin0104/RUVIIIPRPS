#' RUVIII with technical replicates or PRPS normalization.

#' @author Ramyar Molania

#' @description
#' This function applies the RUV-III with technical replicates or PRPS on transcriptions data.

#' @details
#' RUV-III normalization. Before we can describe the linear model underlying RUV-III, we need to introduce the m × m1
#' mapping matrix M connecting assays to distinct samples, which captures the pattern of replication in our assays. Here,
#' m is the number of assays, and m1 is the number of distinct samples being assayed. M(i,h) = 1if assay i is on sample
#' h and M(i,h) = 0 otherwise. Each row of M sums to 1, and the columns sum to the distinct sample replication numbers, the
#' elements of MTM. We also define an m1 × p design matrix X to capture the biological factor(s) of interest indexed by
#' sample rather than assay. There are no constraints on p; indeed, X could be the m1 × m1 identity matrix. Our goal
#' here is to remove unwanted variation, not to estimate regression parameters.
#' The linear model we use is: Y = 1μ + MXβ + Wα + ε
#' where the data Y = (yij)and unobserved errors ε = (εij)are m × n; the matrices X and M have just been defined; μ is
#' the 1 × n row of gene means; β is p × n; the matrix W whose columns capture the unwanted variation is m × k; and α
#' is k × n. 1 = 1m is the m × 1 column vector of 1s. Here, m = number of assays, n = number of genes and p is the
#' dimension of the wanted variation X and k that of the unwanted variation W. Assume that W⊥1. Also, we suppose that we
#' have a subset of nc of negative control genes whose m × nc submatrix Yc satisfies Yc = 1μc + Wαc + εc, where we have
#' assumed that βc = 0—that is, that there is no true association between these genes and the biology of interest.
#' The projection PM = M(M M) M replaces each entry yij of Y by the simple average of the entries yi′j over all i′ for
#' which M (i, h) = M (i′ , h) = 1—that is, over all i′ such that i′ and i label replicate assays of the same unique
#' sample (or pseudo-sample) labeled h. Write RM = I − PM for the corresponding residual projector. This is our source
#' of information on the unwanted variation that we will remove. If the replication is technical at some level, then RMY
#' mainly contains information about unwanted variation in the system after the technical replicates were created.
#' Depending on the study details, technical replicates could be created immediately beforethe assay was run, in parallel
#' with or immediately after sample was collected or somewhere in between. The earlier the creation of technical replicates,
#' the more unwanted variation will be captured in their differences. The use of pseudo-replicates of suitable pseudo-samples
#' enables us to start to deal with pre-technical unwanted variation. Write the spectral decomposition of RMYY RM = UDU ,
#' where U is an m × m orthogonal matrix and D is an m × n diagonal matrix with entries ordered from largest to smallest
#' eigenvalue. Let P1 be the orthogonal projection onto 1m. For a chosen k, 1 ≤ k ≤ m−m1,
#' I- Define αˆ(k) = U(k)TY, where U(k) is the first k columns of U
#' II- Estimate W by regressing the centered negative controls (I − P1)Yc on αˆ(k)T c
#' III-


#' @references
#' Molania R., ..., Speed, T. P., A new normalization for Nanostring nCounter gene expression data, Nucleic Acids Research,
#' 2019.
#' Molania R., ..., Speed, T. P., Removing unwanted variation from large-scale RNA sequencing data with PRPS,
#' Nature Biotechnology, 2023


#' @param se.obj A SummarizedExperiment object.
#' @param assay.name Symbol. Indicates a name of an assay in the SummarizedExperiment object. The selected assay should
#' be the one that was used for PRPS and NCGs selection.
#' @param prps.group Symbol. Denotes which groups of the generated PRPS should be utilized for normalization. The
#' options include 'supervised,' 'unsupervised,' or 'both.' When 'supervised' is chosen, the function employs the PRPS
#' set(s) generated through supervised functions. Opting for 'unsupervised' utilizes the PRPS set(s) created through
#' unsupervised functions. If 'both' is selected, the function utilizes the PRPS set(s) generated by both supervised and
#' unsupervised functions. The default setting is 'supervised.'
#' @param prps.set.names Symbol. sample names/ids or a name of column in sample annotation.
#' @param ncg.group Symbol. Denotes which groups of the selected NCGs should be utilized for normalization. The
#' options include 'supervised,' 'unsupervised,' or 'both.' When 'supervised' is chosen, the function employs the PRPS
#' set(s) generated through supervised functions. Opting for 'unsupervised' utilizes the PRPS set(s) created through
#' unsupervised functions. If 'both' is selected, the function utilizes the PRPS set(s) generated by both supervised and
#' unsupervised functions. The default setting is 'supervised.'
#' @param ncg.set.names Symbol. A symbol or symbols that indicate which specif set(s) of NCG should be used for normalization.
#' If is 'NULL', the function uses all available NCGs of the specified group by "ncg.group".
#' @param k The number of unwanted factors to use. Can be 0, in which case no adjustment is made. Can also be NULL (the
#' default value), in which case the maximum possible value of k is used; note that in this case no singular value
#' decomposition is necessary and execution is faster.
#' @param technical.replicates Symbol. Indicates
#' @param apply.log Logical. Indicates whether to apply a log-transformation to the data, by default it is set to TRUE.
#' @param pseudo.count Numeric. A value as a pseudo count to be added to all measurements before log transformation,
#' by default it is set to 1.
#' @param return.info If FALSE, only the adjusted data matrix is returned. If TRUE, additional information is returned
#' (see below).
#' @param eta Gene-wise (as opposed to sample-wise) covariates. These covariates are adjusted for by RUV-1 before any
#' further analysis proceeds. Can be either (1) a matrix with n columns, (2) a matrix with n rows, (3) a dataframe with
#' n rows, (4) a vector or factor of length n, or (5) simply 1, for an intercept term.
#' @param include.intercept When eta is specified (not NULL) but does not already include an intercept term, this will
#' automatically include one.
#' @param assess.se.obj Logical. Indicates whether to assess the SummarizedExperiment object or not. See the checkSeObj
#' function for more details.
#' @param remove.na Symbol. To remove NA or missing values from the assays or not. The options are 'assays' and 'none'.
#' The default is "assays", so all the NA or missing values from the assay(s) will be removed before computing RLE. See
#' the checkSeObj function for more details.
#' @param save.se.obj Logical. Indicates whether to save the RUV-III-PRPS normalized data as assay(s) in the
#' SummarizedExperiment object or to output the result as list. By default it is set to 'TRUE'.
#' @param verbose Logical. If 'TRUE', shows the messages of different steps of the function.

#' @return SummarizedExperiment A SummarizedExperiment object containing the normalised gene expression
#' into a new assay (RUVIII_K).

#' @importFrom SummarizedExperiment SummarizedExperiment assay colData
#' @importFrom ruv replicate.matrix RUV1
#' @importFrom BiocSingular bsparam
#' @importFrom Matrix solve
#' @export

RUVIII.PRPS <- function(
        se.obj,
        assay.name,
        prps.group = 'supervised',
        prps.set.names = NULL,
        ncg.group = 'supervised',
        ncg.set.names = NULL,
        technical.replicate = NULL,
        k = 1,
        apply.log = 'assay',
        pseudo.count = 1,
        eta = NULL,
        include.intercept = TRUE,
        return.info = FALSE,
        assess.se.obj = TRUE,
        remove.na = 'none',
        output.name = NULL,
        save.se.obj = TRUE,
        verbose = TRUE
        ) {
    printColoredMessage(message = '------------The RUVIII.PRPS function starts:',
                        color = 'white',
                        verbose = verbose)
    # check inputs ####
    if (length(assay.name) > 1) {
        stop('The "assay.name" must be a single assay name.')
    }

    # technical replicates ####
    if(isTRUE(prps.group == "none")){
        if(is.null(technical.replicate))
            stop('To run RUVIII either the "prps.group" or "technical.replicate" or both must be specified.')
    }
    if(!is.null(technical.replicate)){
        if(!technical.replicate %in% colnames(colData(se.obj))){
            stop('The "technical.replicate" cannot be found in the SummarizedExperiment object.')
        }
        rep.samples <- findRepeatingPatterns(vec = colData(se.obj)[[technical.replicate]], n.repeat = 2)
        if(length(rep.samples) == 0){
            stop('The "technical.replicate" contains only unique names. Individual technical replicate sets must have the same names.')
        } else{
            printColoredMessage(message = 'There is(are) ', length(unique(rep.samples)), ' sets of technical replicates in the data.')
        }
        colnames.se.obj <- colnames(colnames(se.obj))
        colnames(se.obj) <- colData(se.obj)[[technical.replicate]]
    } else colnames.se.obj <- colnames(colnames(se.obj))

    ## apply log ####
    if(is.logical(apply.log)){
        stop('The "apply.log" must be one of the "assay", "prps", "both", "none" ')
    }

    # check the SummarizedExperiment object ####
    if (assess.se.obj) {
        se.obj <- checkSeObj(
            se.obj = se.obj,
            assay.names = assay.name,
            variables = NULL,
            remove.na = remove.na,
            verbose = verbose)
    }

    # PRPS ####
    ## check PRPS input ####
    if(!prps.group %in% c('supervised', 'un.supervised', 'both', 'none')){
        stop('The "prps.group" must be of the "supervised", "un.supervised", "both" or "none".')
    }
    if(isTRUE(prps.group != 'none')){
        if(!'PRPS' %in% names(se.obj@metadata)){
            stop('No PRPS data can be found in the metadata of the SummarizedExperiment object.')
        }
    }
    if(!is.null(prps.set.names)){
        if(prps.group == 'supervised'){
            if(!'supervised' %in% names(se.obj@metadata$PRPS)){
                stop('No supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$supervised) == 0){
                stop('No supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(sum(prps.set.names %in% names(se.obj@metadata$PRPS$supervised)) != length(prps.set.names)){
                stop('All or some of "prps.set.names" cannot be found in the SummarizedExperiment object.')
            }
        } else if(prps.group == 'un.supervised'){
            if(!'un.supervised' %in% names(se.obj@metadata$PRPS)){
                stop('No un.supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$un.supervised) == 0){
                stop('No un.supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(sum(prps.set.names %in% names(se.obj@metadata$PRPS$un.supervised)) != length(prps.set.names)){
                stop('All or some of "prps.set.names" cannot be found in the SummarizedExperiment object.')
            }
        } else if (prps.group == 'both'){
            if(!'un.supervised' %in% names(se.obj@metadata$PRPS)){
                stop('No supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(!'supervised' %in% names(se.obj@metadata$PRPS)){
                stop('No supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$supervised) == 0){
                stop('No supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            if(length(se.obj@metadata$PRPS$un.supervised) == 0){
                stop('No un.supervised PRPS data can be found in the SummarizedExperiment object.')
            }
            all.sets <- c(names(se.obj@metadata$PRPS$supervised), names(se.obj@metadata$PRPS$un.supervised))
            if(sum(prps.set.names %in% all.sets != length(prps.set.names))){
                stop('All or some of "prps.set.names" cannot be found in the SummarizedExperiment object.')
            }
        } else if (prps.group == 'none'){
            stop('The "prps.group" cannot be "none" when the "prps.set.names" is not "NULL".')
        }
    }

    ## obtain PRPS data ####
    if(prps.group == 'supervised'){
        if(is.null(prps.set.names)){
            prps.data <- se.obj@metadata$PRPS$supervised
        } else{
            prps.data <- lapply(
                prps.set.names,
                function(x) se.obj@metadata$PRPS$supervised[[x]])
            names(prps.data) <- prps.set.names
        }
        printColoredMessage(
            message = paste0(length(prps.data), ' supervised PRPS set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    } else if (prps.group == 'un.supervised'){
        if(is.null(prps.set.names)){
            prps.data <- se.obj@metadata$PRPS$un.supervised
        } else{
            prps.data <- lapply(
                prps.set.names,
                function(x) se.obj@metadata$PRPS$un.supervisedsupervised[[x]])
            names(prps.data) <- prps.set.names
        }
        printColoredMessage(
            message = paste0(length(prps.data), ' supervised PRPS set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    } else if (prps.group == 'both'){
        if(is.null(prps.set.names)){
            prps.data <- c(se.obj@metadata$PRPS$supervised, se.obj@metadata$PRPS$un.supervised)
        } else{
            prps.data.sup <- lapply(
                prps.set.names,
                function(x) se.obj@metadata$PRPS$supervised[[x]])
            names(prps.data.sup) <- prps.set.names
            prps.data.unsup <- lapply(
                prps.set.names,
                function(x) se.obj@metadata$PRPS$un.supervised[[x]])
            names(prps.data.unsup) <- prps.set.names
            prps.data <- c(prps.data.sup, prps.data.unsup)
            prps.data <- Filter(Negate(is.null), prps.data)
        }
        printColoredMessage(
            message = paste0(length(prps.data), ' supervised/unsupervised PRPS set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    }

    ## check prps data ####
    check.prps.data <- lapply(
        1:length(prps.data),
        function(x){
            lapply(
                seq(prps.data[[x]]),
                function(y){
                    if (nrow(se.obj) != nrow(prps.data[[x]][[y]]) ) {
                        stop('The number of genes between the SummarizedExperiment object and the prps data is not the same.')
                    }
                    if (isFALSE(all.equal(row.names(se.obj), row.names(prps.data[[x]][[y]])))) {
                        stop('The order of genes are not the same between the SummarizedExperiment object and the PRPS data.')
                    }
                    rep.samples <- findRepeatingPatterns(
                        vec = colnames(prps.data[[x]][[y]]),
                        n.repeat = 2)
                    if (length(rep.samples) == 0) {
                        stop('The names of the columns in the prps.data are all unique.')
                    } else if (isTRUE(length(rep.samples) != length(unique(colnames(prps.data[[x]][[y]]))))) {
                        stop('Some names of the columns in the prps.data are all unique.')
                    }
                })
        })
    prps.data <- lapply(
        names(prps.data),
        function(x) do.call(cbind, prps.data[[x]]))
    prps.data <- do.call(cbind, prps.data)


    # NCGs ####
    if(!ncg.group %in% c('supervised', 'un.supervised', 'pre.selected', 'all.genes')){
        stop('The "ncg.group" must be of the "supervised", "un.supervised", "pre.selected" or "all.genes".')
    }
    if(isTRUE(ncg.group != 'all.genes')){
        if(!'NCG' %in% names(se.obj@metadata)){
            stop('No NCG set(s) can be found in the metadata of the SummarizedExperiment object.')
        }
        if(ncg.group == 'supervised'){
            if(!'supervised' %in% names(se.obj@metadata$NCG)){
                stop('No supervised NCG data can be found in the metadata of the SummarizedExperiment object.')
            }
        }
        if(ncg.group == 'un.supervised'){
            if(!'un.supervised' %in% names(se.obj@metadata$NCG)){
                stop('No un.supervised NCG data can be found in the metadata of the SummarizedExperiment object.')
            }
        }

        if(ncg.group == 'pre.selected'){
            if(!'pre.selected' %in% names(se.obj@metadata$NCG)){
                stop('No pre.selected NCG data can be found in the metadata of the SummarizedExperiment object.')
            }
        }
        }


    ## obtain NCG data ####
    if(ncg.group == 'supervised'){
        if(is.null(ncg.set.names)){
            ncg <- se.obj@metadata$NCG$supervised
        } else{
            ncg <- lapply(
                ncg.set.names,
                function(x) se.obj@metadata$NCG$supervised[[x]])
            names(ncg) <- ncg.set.names
        }
        printColoredMessage(
            message = paste0(length(ncg), ' supervised NCG set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    } else if (ncg.group == 'un.supervised'){
        if(is.null(ncg.set.names)){
            ncg <- se.obj@metadata$NCG$un.supervised
        } else{
            ncg <- lapply(
                ncg.set.names,
                function(x) se.obj@metadata$NCG$un.supervised[[x]])
            names(ncg) <- ncg.set.names
        }
        printColoredMessage(
            message = paste0(length(ncg), ' supervised NCG set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    } else if (ncg.group == 'pre.selected'){
        if(is.null(ncg.set.names)){
            ncg <- se.obj@metadata$NCG$pre.selected
        } else{
            ncg <- lapply(
                ncg.set.names,
                function(x) se.obj@metadata$NCG$pre.selected[[x]])
            names(ncg) <- ncg.set.names
        }
        printColoredMessage(
            message = paste0(length(ncg), ' supervised NCG set(s) are found in the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)
    } else if (ncg.group == 'all.genes'){
        ncg <- list(all.genes = row.names(se.obj) %in% row.names(se.obj))
    }
    ncg <- do.call(cbind, ncg)
    ncg <- rowSums(ncg) != 0

    # check K ####
    if (min(k) <= 0) stop('k cannot be 0 or negative values.')

    # check max k for each normalization ####
    M <- ruv::replicate.matrix(colnames(prps.data))
    max.k.values <- min(ncol(M), sum(ncg))
    printColoredMessage(
        message = paste0('The maximum k for the curret PRPS data and NCGs is ', max.k.values, '.'),
        color = 'blue',
        verbose = verbose)

    # possible runs of RUV-III ####
    printColoredMessage(message = '-- Possible runs of the RUV-III-PRPS method:',
                        color = 'magenta',
                        verbose = verbose)

    if(isTRUE(length(k) == 1)){
        if(max.k.values >= k){
            printColoredMessage(
                message = paste0('The RUV-III will be performed with k = ', k, '.'),
                color = 'blue',
                verbose = verbose)
        } else if( k > max.k.values ){
            printColoredMessage(
                message = 'Please note, the specifed k value is greate than possible maximum k for the curret PRPS data and NCGs',
                color = 'red',
                verbose = verbose)
            printColoredMessage(
                message = paste0('The RUV-III will be performed with k = ', max.k.values, '.'),
                color = 'blue',
                verbose = verbose)
            k <- max.k.values
        }
    } else if (isTRUE(length(k) > 1)){
        if( max.k.values >= max(k) ){
            printColoredMessage(
                message = paste0('The RUV-III will be performed with k = ', paste0(k, collapse = ','), '.'),
                color = 'blue',
                verbose = verbose)
        } else if ( max(k) >  max.k.values){
            printColoredMessage(
                message = 'Please note, the maximum of specifed k values is greate than possible maximum k for the curret PRPS data and NCGs',
                color = 'red',
                verbose = verbose)
        }
        k <- k[ k <= max.k.values]
        printColoredMessage(
            message = paste0('The RUV-III will be performed with k = ', paste0(k, collapse = ','), '.'),
            color = 'blue',
            verbose = verbose)
    }

    printColoredMessage(
        message = paste0('In totall ', length(k), ' runs of RUV-III-PRPS will applied.'),
        color = 'blue',
        verbose = verbose)

    # data transformation ####
    if (is.null(pseudo.count)) pseudo.count = 0
    printColoredMessage(message = '-- Data transformation:',
                        color = 'magenta',
                        verbose = verbose)
    printColoredMessage(message = 'Note, make sure both the assay and PRPS data are log transformed.',
                        color = 'red',
                        verbose = verbose)
    if (apply.log == 'both') {
        printColoredMessage(
            message = paste('Apply log2 + ', pseudo.count, ' (pseudo.count) on both assay and prps data.'),
            color = 'blue',
            verbose = verbose
        )
        Y <- log2(assay(se.obj, assay.name) + pseudo.count)
        prps.data <- log2(prps.data + pseudo.count)
    } else if (apply.log == 'assay') {
        printColoredMessage(
            message = paste0('Apply log2 + ', pseudo.count, ' (pseudo.count) on only assay.'),
            color = 'blue',
            verbose = verbose
        )
        Y <- log2(assay(se.obj, assay.name) + pseudo.count)
    } else if (apply.log == 'prps') {
        printColoredMessage(
            message = paste('Apply log2 + ', pseudo.count, ' (pseudo.count) on only assay.'),
            color = 'blue',
            verbose = verbose
        )
        prps.data <- log2(prps.data + pseudo.count)
    } else if (apply.log == 'none') {
        printColoredMessage(message = 'It seems both assay and PRPS are already log transformed.',
                            color = 'blue',
                            verbose = verbose)
        Y <- assay(x = se.obj, i = assay.name)
    }

    # RUVIII normalization ####
    printColoredMessage(message = '-- Apply the RUV-III-PRPS method:',
                        color = 'magenta',
                        verbose = verbose)
    if (length(k) > 1) {
        printColoredMessage(message = 'The alpha will be calculated for the maximum value of k.',
                            color = 'blue',
                            verbose = verbose)
        # ncg ####
        ncg.set <- ncg
        ncg.logi <- rep(FALSE, nrow(se.obj))
        ncg.logi[ncg.set] <- TRUE
        ncg.set <- ncg.logi
        # prps dara ####
        prps.data <- prps.data
        k.vals <- k
        # apply RUV1 on Y ####
        Y <- t(cbind(Y, prps.data))
        if (is.data.frame(Y))
            Y <- data.matrix(Y)
        if (sum(is.na(Y)) > 0) {
            stop("The assay or PRPS data contains missing values. This is not supported.")
        } else if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) > 0) {
            stop("The assay or PRPS data contains infinity values. This is not supported.")
        }
        printColoredMessage(message = '-Apply RUV1 on the both assay and prps data:',
                            color = 'blue',
                            verbose = verbose)
        Y <- ruv::RUV1(
            Y = Y,
            eta = eta,
            ctl = ncg.set,
            include.intercept = include.intercept
        )
        # data standardization ####
        printColoredMessage(message = '-Standardize the data:',
                            color = 'blue',
                            verbose = verbose)
        Y.stand <- scale(Y, center = TRUE, scale = FALSE)
        printColoredMessage(message = '-Create M martix:',
                            color = 'blue',
                            verbose = verbose)
        M <- replicate.matrix(row.names(Y))
        printColoredMessage(message = '-Sanity check on the M matrix:',
                            color = 'blue',
                            verbose = verbose)
        sum(rowSums(M) != 1)
        sum(colSums(M) == 1)
        printColoredMessage(message = '-Obtain residuals from the PRPS sets:',
                            color = 'blue',
                            verbose = verbose)
        Y0 <- fastResidop2(Y, M)
        printColoredMessage(message = '-Apply svd on the residuals to obtain alpha:',
                            color = 'blue',
                            verbose = verbose)
        left.sing.value <- BiocSingular::runSVD(
            x = Y0,
            k = max(k.vals),
            BSPARAM = bsparam(),
            center = FALSE,
            scale = FALSE
        )$u
        alpha <- t(left.sing.value[, 1:max(k.vals), drop = FALSE]) %*% Y
        ac <- alpha[, ncg.set, drop = FALSE]
        printColoredMessage(message = '-Obtain W :',
                            color = 'blue',
                            verbose = verbose)
        W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
        printColoredMessage(message = '-Obtain the normalized data for the maximum value of k:',
                            color = 'blue',
                            verbose = verbose)
        newY.max <- Y - W %*% alpha
        newY.max <- t(newY.max[1:ncol(se.obj) ,])
        newY.max <- list(newY = newY.max, W = W[1:ncol(se.obj) , , drop = FALSE])
        ## other k
        other.k <- k.vals[!k.vals %in% max(k.vals)]
        printColoredMessage(message = '-Obtain the normalized data for the values of k:',
                            color = 'blue',
                            verbose = verbose)
        all.ruv <- lapply(
            other.k,
            function(y) {
                alpha <- t(left.sing.value[, 1:y, drop = FALSE]) %*% Y
                ac <- alpha[1:y, ncg.set, drop = FALSE]
                W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
                newY <- Y - W %*% alpha
                newY <- t(newY[1:ncol(se.obj) , ])
                return(list(newY = newY, W = W[1:ncol(se.obj) , , drop = FALSE]))
            })
        all.ruv[[length(k.vals)]] <- newY.max
        if(is.null(output.name)){
            print('hhhhhhh')
            names(all.ruv) <- paste0('RUVIIIRPPS_K.', k.vals)
        } else names(all.ruv) <- paste0(output.name, k.vals)

    } else {
        ncg.set <- ncg
        ncg.logi <- rep(FALSE, nrow(se.obj))
        ncg.logi[ncg.set] <- TRUE
        ncg.set <- ncg.logi
        prps.data <- prps.data
        k.vals <- k
        # apply RUV1 on Y ####
        Y <- t(cbind(Y, prps.data))
        if (is.data.frame(Y))
            Y <- data.matrix(Y)
        if (sum(is.na(Y)) > 0) {
            stop("The assay or PRPS data contains missing values. This is not supported.")
        } else if (sum(Y == Inf, na.rm = TRUE) + sum(Y == -Inf, na.rm = TRUE) > 0) {
            stop("The assay or PRPS data contains infinity values. This is not supported.")
        }
        printColoredMessage(message = 'Apply RUV1 on the both assay and prps data:',
                            color = 'blue',
                            verbose = verbose)
        Y <- RUV1(
            Y = Y,
            eta = eta,
            ctl = ncg.set,
            include.intercept = include.intercept
        )
        # data standardization ####
        printColoredMessage(message = '-Standardize the data:',
                            color = 'blue',
                            verbose = verbose)
        Y.stand <- scale(Y, center = TRUE, scale = FALSE)
        printColoredMessage(message = '-Create M martix:',
                            color = 'blue',
                            verbose = verbose)
        M <- replicate.matrix(row.names(Y))
        printColoredMessage(message = '-Sanity check on the M matrix:',
                            color = 'blue',
                            verbose = verbose)
        sum(rowSums(M) != 1)
        sum(colSums(M) == 1)
        printColoredMessage(message = '-Obtain residuals from the PRPS sets:',
                            color = 'blue',
                            verbose = verbose)
        Y0 <- fastResidop2(Y, M)
        printColoredMessage(message = '-Apply svd on the residuals to Obtain alpha:',
                            color = 'blue',
                            verbose = verbose)
        left.sing.value <- BiocSingular::runSVD(
            x = Y0,
            k = max(k.vals),
            BSPARAM = bsparam(),
            center = FALSE,
            scale = FALSE
        )$u
        alpha <- t(left.sing.value[, 1:k.vals, drop = FALSE]) %*% Y
        ac <- alpha[, ncg.set, drop = FALSE]
        printColoredMessage(message = '-Obtain W :',
                            color = 'blue',
                            verbose = verbose)
        W <- Y.stand[, ncg.set] %*% t(ac) %*% solve(ac %*% t(ac))
        newY <- Y - W %*% alpha
        newY <- t(newY[1:ncol(se.obj) ,])
        all.ruv <- list(newY = newY, W = W[1:ncol(se.obj) , , drop = FALSE])
        if(is.null(output.name))  output.name <- paste0('RUVIIIRPPS_K.', k.vals)
    }

    # save data sets ####
    ## Saving the norm data into a new assay ####
    print('hhhhhhhoooo')
    if (save.se.obj) {
        if(length(k == 1)){
            newY <- all.ruv$newY
            colnames(newY) <- colnames.se.obj
            se.obj@assays@data[[output.name]] <- newY
        } else{
            for (x in 1:length(all.ruv)) {
                newY <- all.ruv[[x]]$newY
                colnames(newY) <- colnames.se.obj
                se.obj@assays@data[[names(all.ruv[x])]] <- newY
            }
        }
        printColoredMessage(
            message = paste0(
                'The normalized data is saved into a new assay of the SummarizedExperiment object.'),
            color = 'blue',
            verbose = verbose)

        # saving the W and alpha as well ####
        if (return.info) {
            ## Check if metadata RUVIII already exist
            if (length(se.obj@metadata) == 0) {
                se.obj@metadata[['RUVIII']] <- list()
            }
            ## Check if metadata RUVIII already exist
            if (!'RUVIII' %in% names(se.obj@metadata)) {
                se.obj@metadata[['RUVIII']] <- list()
            }
            if(length(k) == 1){
                ## Check if metadata RUVIII already exist for this assay
                if (!output.name %in% names(se.obj@metadata[['RUVIII']])) {
                    se.obj@metadata[['RUVIII']][[output.name]] <- list()
                }
                ## Check if metadata RUVIII already exist for this assay for W
                if (!'W' %in% names(se.obj@metadata[['RUVIII']][[output.name]])) {
                    se.obj@metadata[['RUVIII']][[output.name]][['W']]  <- list()
                }
                se.obj@metadata[['RUVIII']][[output.name]][['W']] <- all.ruv$W
            } else if (length(k) > 1){
                for(x in 1:length(all.ruv)){
                    output.name <- names(all.ruv[x])
                    ## Check if metadata RUVIII already exist for this assay
                    if (!output.name %in% names(se.obj@metadata[['RUVIII']])) {
                        se.obj@metadata[['RUVIII']][[output.name]] <- list()
                    }
                    ## Check if metadata RUVIII already exist for this assay for W
                    if (!'W' %in% names(se.obj@metadata[['RUVIII']][[output.name]])) {
                        se.obj@metadata[['RUVIII']][[output.name]][['W']]  <- list()
                    }
                    se.obj@metadata[['RUVIII']][[output.name]][['W']] <- all.ruv[[x]]$W
                }
            }
        }
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(se.obj)
    } else if (!return.info & !save.se.obj) {
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(all.ruv)
    } else if (return.info & !save.se.obj) {
        printColoredMessage(message = '------------The RUVIII.PRPS function finished.',
                            color = 'white',
                            verbose = verbose)
        return(all.ruv)
    }
}
