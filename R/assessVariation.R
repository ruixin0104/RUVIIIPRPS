#' Assess the variation of biological and unwanted variables.

#' @author Ramyar Molania

#' @description
#' This function applies a range of global and gene level metrics to assess the variation in biological and unwanted
#' variables in the assay(s) of a SummarizedExperiment object. The result of individual metric will be plotted.

#' @details
#' Several assessment will be performed:
#' For each categorical variable:
#' - PCA plot of the categorical variable.
#' - Silhouette and ARI computed on the categorical variable.
#' - Differential analysis based ANOVA between the gene expression and the categorical variable.
#' - Vector correlation between the first cumulative PCs of the gene expression and the categorical variable.
#' For each continous variable:
#' - Linear regression between the first cumulative PC and continuous variable.
#' - Correlation between gene expression and continuous variable.
#'
#' It will output the following plots:
#' - PCA plot of each categorical variable.
#' - Boxplot of the F-test distribution from ANOVA between the gene expression and each categorical variable.
#' - Vector correlation between the first cumulative PCs of the gene expression and each categorical variable.
#' - Combined Silhouette plot of the combined pair of all categorical variables.
#' - Linear regression between the first cumulative PC and continuous variable.
#' - Boxplot of the correlation between gene expression and continuous variable.
#' - It will also output the RLE plot distribution.

#' @references
#' Molania R., ..., Speed, T. P., A new normalization for Nanostring nCounter gene expression data, Nucleic Acids Research,
#' 2019.
#'
#' Molania R., ..., Speed, T. P., Removing unwanted variation from large-scale RNA sequencing data with PRPS,
#' Nature Biotechnology, 2023


#' @param se.obj A SummarizedExperiment object.
#' @param assay.names Symbol. A symbol or a vector of symbols for the selection of the name(s) of the assay(s) in the
#' SummarizedExperiment object. The default is set to 'all', so all the assays in the SummarizedExperiment object will
#' be selected.
#' @param variables Symbols. Indicating the the column names containing variable(s) for assessing their variation within
#' the SummarizedExperiment object. These variables may be either categorical or continuous.
#' @param metrics.to.exclude Symbols. A symbol or vector of symbols indication which metrics to be excluded.
#' The metrics can be obtained using the  'getAssessmentMetrics' function. The default is set to NULL. Refer
#' to the details for more information.
#' @param plots.to.exclude Symbols. A symbol or vector of symbols indicating which plots to exclude. These metrics can
#' be acquired using the 'getAssessmentMetrics' function. Default is set to NULL. See the details for further information.
#' @param apply.log Logical. Indicates whether to apply a log-transformation to the data. By default
#' no transformation will be selected.
#' @param pseudo.count Numeric. A value as a pseudo count to be added to all measurements before log transformation,
#' by default it is set to 1.
#' @param general.points.size Numeric. The size of points in all the scatter plots generated by the functions. The default
#' is set to 1.
#' @param rle.iqr.width Numeric. Indicates the width of the RLE IQR in the RLE plots. The default is set to 1.
#' @param rle.median.points.size Numeric. Indicates the size of the points of the RLE medians in the RLE plots . The default
#' is set to 1.
#' @param rle.median.points.color Numeric. Indicates the color of the points of the RLE medians in the RLE plots. The default
#' is set to 'red'.
#' @param rle.geom.hline.color Symbol. Indicates the color of the horizontal line in the RLE plots. The default is set
#' to 'cyan'.
#' @param rle.plot.ncol Numeric. Indicates the columns of the plot grid in the RLE plots. The default is set to 1.
#' @param rle.plot.nrow Numeric. Indicates the rows of the plot grid in the RLE plots. The default is set to 3.
#' @param rle.variables.colors List. Indicates selected colors for each variables for colored RLE plots. The default is
#' set to 'NULL', then the function use the default colors.
#' @param fast.pca Logical. Indicates whether to calculate a specific number of PCs instead of the full range to speed up
#' the process. The default is set to 'TRUE'. Refer to the function 'computePCA' for more details.
#' @param compute.nb.pcs Numeric. The number of first PCs to be calculated for the fast pca process. The default is set to 4.
#' @param nb.pcs.toplot.pca Numeric. Indicates the number of PCs to be plotted against each other. The default is set to 3.
#' The value cannot be larger then 'compute.nb.pcs'.
#' @param center Logical. Indicates whether to scale the data or not before applying SVD. If center is 'TRUE', then centering is done by
#' subtracting the column means of the assay from their corresponding columns. The default is 'TRUE'.
#' @param scale Logical. Indicates whether to scale the data or not before applying SVD.  If scale is TRUE, then scaling
#' is done by dividing the (centered) columns of the assays by their standard deviations if center is TRUE, and the root
#' mean square otherwise. The default is 'FALSE'.
#' @param svd.bsparam A BiocParallelParam object specifying how parallelization should be performed. The default is bsparam().
#' We refer to the 'runSVD' function from the BiocSingular R package.
#' @param pca.variables.colors List. Indicates selected colors for each variables for PCA plots. The default is
#' set to 'NULL', then the function uses the default colors.
#' @param sil.dist.measure Symbol. Indicates which ditsance measure to be used. The options are 'euclidean', 'maximum',
#' 'manhattan', 'canberra', 'binary' or 'minkowski'. The default is set to 'euclidean'. Refer to the function 'dist' from
#' the R package stats for more details.
#' @param sli.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the silhouette coefficients. The
#' default is set to 3.
#' @param ari.clustering.method Symbol. A symbol that indicates which clustering methods should be applied on the PCs to
#' calculate the ARI. The options are 'mclust' or 'hclust' methods. The default is set to 'hclust'.
#' @param ari.hclust.method Symbol. Indicate the agglomeration method to be used when the  'clustering.method' is 'hclust'
#' method. The options are: 'ward.D', 'ward.D2', 'single', 'complete', 'average' (= UPGMA), 'mcquitty' (= WPGMA),
#' 'median' (= WPGMC) or centroid' (= UPGMC). Refer to the 'hclust' function from the stats R package for more details.
#' @param ari.hclust.dist.measure Symbol. Indicates the distance measure to be used in the 'dist' function. The options are
#' 'euclidean', 'maximum', 'manhattan', 'canberra', 'binary' or 'minkowski'. Refer to the 'dist' function from the stats
#' R package for more details.
#' @param ari.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the ARI. The default is set to 3.
#' This number cannot be larger than 'compute.nb.pcs'.
#' @param vca.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the vector correlation analysis.
#' The default is set to 3. This number cannot be larger than 'compute.nb.pcs'.
#' @param lra.nb.pcs Numeric. Indicates the number of PCs that should be used to compute the linear regression analysis.
#' The default is set to 3. This number cannot be larger than 'compute.nb.pcs'.
#' @param corr.method Symbol. Indicates which correlation method should be used to compute association between gene-level
#' expression and a continuous variable. The options are 'pearson', 'kendall', or "spearman". The default is set to 'spearman'.
#' @param a Numeric. The significance level used for the confidence intervals in the correlation. The default is set to
#' 0.05. Refer to the 'correls' function from the 'Rfast' R package for more details.
#' @param rho Numeric. The value of the hypothesized correlation to be used in the hypothesis testing. The default is
#' set to 0. Refer to the 'correls' function from the 'Rfast' R package for more details.
#' @param anova.method Indicates which anova method should be used to compute association between gene-level expression
#' and a categorical variable. The options are 'aov' and 'welch'. The default is set to 'aov'.
#' @param deg.plot.ncol Indicates the columns of the plot grid in the p-value histograms plots. The default is set to 1.
#' @param deg.plot.nrow Indicates the rows of the plot grid in the p-value histograms plots. The default is set to 3.
#' @param assess.se.obj Logical. Indicates whether to assess the SummarizedExperiment class object.
#' @param remove.na Symbol. To remove NA or missing values from the assays or not. The options are 'assays' and 'none'.
#' The default is "assays", so all the NA or missing values from the assay(s) will be removed before computing RLE. See
#' the checkSeObj function for more details.
#' @param output.file.name Path and name of the output file to save the assessments plots in a pdf format.
#' @param verbose Logical. If TRUE, displaying process messages is enabled.

#' @return A SummarizedExperiment object containing all the assessments plots and metrics. If specified it will generate
#' a pdf containing the assessments plots and metrics used for the assessment.

#' @importFrom grDevices colorRampPalette dev.off pdf
#' @importFrom SummarizedExperiment assays colData
#' @importFrom gridExtra grid.arrange grid.table
#' @importFrom ggforestplot geom_stripes
#' @importFrom RColorBrewer brewer.pal
#' @importFrom graphics plot.new text
#' @export


# se.obj = brca.se.obj
# assay.names = 'all'
# variables = c('PAM50', 'library.size')
# metrics.to.exclude = NULL
# plots.to.exclude = NULL
# apply.log = TRUE
# pseudo.count = 1
# general.points.size = 1
# rle.iqr.width = 2
# rle.median.points.size = 1
# rle.median.points.color = 'red'
# rle.geom.hline.color = "cyan"
# rle.plot.ncol = 1
# rle.plot.nrow = 3
# rle.variables.colors = NULL
# fast.pca = TRUE
# compute.nb.pcs = 5
# nb.pcs.toplot.pca = 3
# center = TRUE
# scale = FALSE
# svd.bsparam = bsparam()
# pca.variables.colors = NULL
# sil.dist.measure = 'euclidian'
# sli.nb.pcs = 3
# ari.clustering.method = "hclust"
# ari.hclust.method = "complete"
# ari.hclust.dist.measure = "euclidian"
# ari.nb.pcs = 3
# vca.nb.pcs = 3
# lra.nb.pcs = 3
# corr.method = 'spearman'
# a = 0.05
# rho = 0
# anova.method = 'aov'
# deg.plot.ncol = 1
# deg.plot.nrow = 3
# assess.se.obj = TRUE
# remove.na = 'none'
# output.file.name = NULL
# verbose = TRUE



assessVariation <- function(
        se.obj,
        assay.names = 'all',
        variables,
        metrics.to.exclude = NULL,
        plots.to.exclude = NULL,
        apply.log = TRUE,
        pseudo.count = 1,
        general.points.size = 1,
        rle.iqr.width = 2,
        rle.median.points.size = 1,
        rle.median.points.color = 'red',
        rle.geom.hline.color = "cyan",
        rle.plot.ncol = 1,
        rle.plot.nrow = 3,
        rle.variables.colors = NULL,
        fast.pca = TRUE,
        compute.nb.pcs = 5,
        nb.pcs.toplot.pca = 3,
        center = TRUE,
        scale = FALSE,
        svd.bsparam = bsparam(),
        pca.variables.colors = NULL,
        sil.dist.measure = 'euclidian',
        sli.nb.pcs = 3,
        ari.clustering.method = "hclust",
        ari.hclust.method = "complete",
        ari.hclust.dist.measure = "euclidian",
        ari.nb.pcs = 3,
        vca.nb.pcs = 3,
        lra.nb.pcs = 3,
        corr.method = 'spearman',
        a = 0.05,
        rho = 0,
        anova.method = 'aov',
        deg.plot.ncol = 1,
        deg.plot.nrow = 3,
        assess.se.obj = TRUE,
        remove.na = 'none',
        output.file.name = NULL,
        verbose = TRUE
        ){
    printColoredMessage(message = '------------The assessVariation function starts:',
                        color = 'white',
                        verbose = verbose)
    # Check the inputs of function ####
    if(!is.vector(assay.names)  | is.logical(assay.names) ){
        stop('The "assay.names" must be a single assay name or assay.names = "all" in the SummarizedExperiment object.')
    }
    if (length(assay.names) == 1 && assay.names != 'all') {
        if (!assay.names %in% names(assays(se.obj)))
            stop('The "assay.names" cannot be found in the SummarizedExperiment object.')
    }
    if (length(assay.names) > 1) {
        if (length(setdiff(assay.names, names(assays(se.obj)))) > 0)
            stop('The "assay.names" cannot be found in the SummarizedExperiment object.')
    }
    if(is.null(variables)){
        stop('The "variables" cannot be empty or NULL.')
    }
    if(is.logical(metrics.to.exclude) | is.logical(plots.to.exclude)){
        stop('The "metrics.to.exclude" or "plots.to.exclude" must be a vector or NULL.')
    }
    if (isFALSE(is.logical(apply.log))) {
        stop('The "apply.log" must be "TRUE" or "FALSE".')
    }
    if(isTRUE(apply.log)){
        if(length(pseudo.count) > 1 | pseudo.count < 0 | is.null(pseudo.count))
            stop('The "pseudo.count" must be 0 or a postive numeric value.')
    }
    if (isFALSE(is.logical(fast.pca))) {
        stop('The "fast.pca" must be "TRUE" or "FALSE".')
    }
    if (compute.nb.pcs < 0 | is.logical(compute.nb.pcs)){
        stop('The "compute.nb.pcs" must be a postive numeric value.')
    }
    if (isFALSE(is.logical(scale))) {
        stop('The "scale" must be "TRUE" or "FALSE".')
    } else if (isFALSE(is.logical(center))) {
        stop('The "center" must be "TRUE" or "FALSE".')
    }

    if(isTRUE(sli.nb.pcs) > compute.nb.pcs){
        stop('The "sli.nb.pcs" cannot be larger than "compute.nb.pcs".')
    }
    if(isTRUE(ari.nb.pcs) > compute.nb.pcs){
        stop('The "ari.nb.pcs" cannot be larger than "compute.nb.pcs".')
    }
    if(isTRUE(nb.pcs.toplot.pca) > compute.nb.pcs){
        stop('The "nb.pcs.toplot.pca" cannot be larger than "compute.nb.pcs".')
    }
    if(isTRUE(vca.nb.pcs) > compute.nb.pcs){
        stop('The "vca.nb.pcs" cannot be larger than "compute.nb.pcs".')
    }
    if(isTRUE(lra.nb.pcs) > compute.nb.pcs){
        stop('The "lra.nb.pcs" cannot be larger than "compute.nb.pcs".')
    }
    if (fast.pca & is.null(compute.nb.pcs)) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    } else if (fast.pca & compute.nb.pcs == 0) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    }
    if (isTRUE(is.logical(output.file.name))) {
        stop('The "output.file.name" must be a character name or "NULL".')
    }
    if (fast.pca & is.null(compute.nb.pcs)) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    } else if (fast.pca & compute.nb.pcs == 0) {
        stop('To perform fast PCA, the number of PCs (compute.nb.pcs) must specified.')
    }

    # Assays ####
    if (length(assay.names) == 1 && assay.names == 'all') {
        assay.names <- factor(x = names(assays(se.obj)), levels = names(assays(se.obj)))
    } else assay.names <- factor(x = assay.names, levels = assay.names)
    if(!sum(assay.names %in% names(assays(se.obj))) == length(assay.names)){
        stop('The "assay.names" cannot be found in the SummarizedExperiment object.')
    }

    # Assess the SummarizedExperiment object ####
    if (isTRUE(assess.se.obj)) {
        se.obj <- checkSeObj(
            se.obj = se.obj,
            assay.names = assay.names,
            variables = variables,
            remove.na = remove.na,
            verbose = verbose)
    }
    # All possible metrics for each variable #####
    printColoredMessage(
        message = 'Find all possible assessment metrics:',
        color = 'magenta',
        verbose = verbose)
    se.obj <- getAssessmentMetrics(
        se.obj = se.obj,
        variables = variables,
        plot.output = FALSE,
        save.se.obj = TRUE)
    # Metrics and plots to generate #####
    metrics.table <- se.obj@metadata$AssessmentMetrics$metrics.table
    if(!is.null(metrics.to.exclude)){
        metrics.table <- metrics.table[!metrics.table$Metrics %in% metrics.to.exclude, ]
    }
    if(!is.null(plots.to.exclude)){
        plots.table <- metrics.table[!metrics.table$Code %in% plots.to.exclude, ]
    } else plots.table <- metrics.table

    printColoredMessage(
        message = paste0(
            nrow(se.obj@metadata$AssessmentMetrics$metrics.table),
            ' assessment plots will be generated.'),
        color = 'blue',
        verbose = verbose)

    ## RLE #####
    ### compute rle #####
    if('RLE' %in% metrics.table$Metrics){
        if('rlePlot' %in% metrics.table$PlotTypes ){
            rle.outputs.to.return <- 'all'
        } else rle.outputs.to.return <- 'rle.med.iqr'
        se.obj <- computeRLE(
            se.obj = se.obj,
            assay.names = assay.names,
            apply.log = apply.log,
            pseudo.count = pseudo.count,
            outputs.to.return = rle.outputs.to.return,
            assess.se.obj = FALSE,
            remove.na = 'none',
            save.se.obj = TRUE,
            verbose = verbose)
    }

    ### plot general rle #####
    if('rlePlot' %in% plots.table$PlotTypes){
        se.obj <- plotRLE(
            se.obj = se.obj,
            assay.names = assay.names,
            variable = NULL,
            variable.colors = NULL,
            ylim.rle.plot = NULL,
            iqr.width = rle.iqr.width,
            median.points.size = rle.median.points.size,
            median.points.color = rle.median.points.color,
            geom.hline.color = rle.geom.hline.color,
            plot.ncol = rle.plot.ncol,
            plot.nrow = rle.plot.nrow,
            plot.output = FALSE,
            save.se.obj = TRUE,
            verbose = verbose)
    }

    ### plot colored rle #####
    if('coloredRLEplot' %in% plots.table$PlotTypes){
        coloredRLEplot.vars <- plots.table$PlotTypes == 'coloredRLEplot'
        coloredRLEplot.vars <- metrics.table$Variables[coloredRLEplot.vars]
        for(i in coloredRLEplot.vars){
            se.obj <- plotRLE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                variable.colors = rle.variables.colors,
                ylim.rle.plot = NULL,
                iqr.width = rle.iqr.width,
                median.points.size = rle.median.points.size,
                median.points.color = "grey",
                geom.hline.color = rle.geom.hline.color,
                plot.ncol = rle.plot.ncol,
                plot.nrow = rle.plot.nrow,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot rle medians with variable #####
    if('rleMedians' %in% plots.table$Factors){
        rleMedplot.vars <- plots.table$Factors == 'rleMedians'
        rleMedplot.vars <- plots.table$Variables[rleMedplot.vars]
        for(i in rleMedplot.vars){
            se.obj <- plotRleVariable(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                rle.data.type = 'rle.medians',
                ylim.rle.med.plot = NULL,
                ylim.rle.iqr.plot = NULL,
                points.size = general.points.size,
                plot.ncol = 3,
                plot.nrow = 3,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### plot rle iqr with variable #####
    if('rleIqr' %in% plots.table$Factors){
        rleIqrplot.vars <- plots.table$Factors == 'rleIqr'
        rleIqrplot.vars <- plots.table$Variables[rleIqrplot.vars]
        for(i in rleIqrplot.vars){
            se.obj <- plotRleVariable(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                rle.data.type = 'rle.iqr',
                ylim.rle.med.plot = NULL,
                ylim.rle.iqr.plot = NULL,
                points.size = general.points.size,
                plot.ncol = 3,
                plot.nrow = 3,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## PCA ####
    ### compute pca ####
    if('PCA' %in% metrics.table$Metrics){
        se.obj <- computePCA(
            se.obj = se.obj,
            assay.names = assay.names,
            fast.pca = fast.pca,
            nb.pcs = compute.nb.pcs,
            center = center,
            scale = scale,
            apply.log = apply.log,
            pseudo.count = pseudo.count,
            svd.bsparam = svd.bsparam,
            assess.se.obj = FALSE,
            remove.na = 'none',
            save.se.obj = TRUE,
            verbose = verbose)
    }

    ### scatter plot pca ####
    if('PCA' %in% plots.table$Metrics & 'scatterPlot' %in% plots.table$PlotTypes){
        pca.scatter.vars <- plots.table$Metrics == 'PCA' & plots.table$PlotTypes == 'scatterPlot'
        pca.scatter.vars <- plots.table$Variables[pca.scatter.vars]
        for(i in pca.scatter.vars){
            se.obj <- RUVIIIPRPS::plotPCA(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = nb.pcs.toplot.pca,
                plot.type = "scatter",
                variable.colors = pca.variables.colors,
                points.size = general.points.size,
                stroke.color = "gray30",
                stroke.size = 0.2,
                points.alpha = 0.5,
                densities.alpha = 0.5,
                plot.ncol = c(3,1),
                plot.nrow = c(3,2),
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }

    ### boxplot pca ####
    if('PCA' %in% plots.table$Metrics & 'boxPlot' %in% plots.table$PlotTypes){
        pca.boxplot.vars <- plots.table$Metrics == 'PCA' & metrics.table$PlotTypes == 'boxPlot'
        pca.boxplot.vars <- plots.table$Variables[pca.boxplot.vars]
        for(i in pca.boxplot.vars){
            se.obj <- RUVIIIPRPS::plotPCA(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = nb.pcs.toplot.pca,
                plot.type = "boxplot",
                variable.colors = pca.variables.colors,
                points.size = general.points.size,
                stroke.color = "gray30",
                stroke.size = 0.2,
                points.alpha = 0.5,
                densities.alpha = 0.5,
                plot.ncol = c(3,1),
                plot.nrow = c(3,2),
                plot.output = F,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }

    ## Vector correlation ####
    ### compute vector correlation ####
    if('VCA' %in% metrics.table$Metrics){
        pc.vec.corr.vars <- metrics.table$Metrics == 'VCA'
        pc.vec.corr.vars <- metrics.table$Variables[pc.vec.corr.vars]
        for(i in pc.vec.corr.vars){
            se.obj <- computePCVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = vca.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### plot vector correlation ####
    if('VCA' %in% plots.table$Metrics){
        index <- plots.table$Metrics == 'VCA'
        pc.vec.corr.vars <- plots.table$Variables[index]
        for(i in pc.vec.corr.vars){
            se.obj <- plotPCVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = vca.nb.pcs,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Linear regression ####
    ### compute linear regression ####
    if('LRA' %in% metrics.table$Metrics){
        pc.reg.vars <- metrics.table$Metrics == 'LRA'
        pc.reg.vars <- metrics.table$Variables[pc.reg.vars]
        for(i in pc.reg.vars){
            se.obj <- computePCVariableRegression(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = lra.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### plot linear regression ####
    if('LRA' %in% plots.table$Metrics){
        pc.reg.vars <- plots.table$Metrics == 'LRA'
        pc.reg.vars <- plots.table$Variables[pc.reg.vars]
        for(i in pc.reg.vars){
            se.obj <- plotPCVariableRegression(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                fast.pca = fast.pca,
                nb.pcs = lra.nb.pcs,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Silhouette coefficient ####
    ### compute silhouette coefficients ####
    if('Silhouette' %in% metrics.table$Metrics){
        index.single <- metrics.table$Metrics == 'Silhouette' &
            metrics.table$PlotTypes == 'barPlot'
        sil.single.vars <- metrics.table$Variables[index.single]
        index.combined <- metrics.table$Metrics == 'Silhouette' &
            metrics.table$PlotTypes == 'combinedPlot'
        sil.combined.vars <- metrics.table$Variables[index.combined]
        sil.combined.vars <- unlist(strsplit(x = sil.combined.vars, split = '&'))
        all.sil.vars <- unique(c(sil.single.vars, sil.combined.vars))
        for(i in all.sil.vars){
            se.obj <- computeSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                dist.measure = sil.dist.measure,
                fast.pca = fast.pca,
                nb.pcs = sli.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### barplot silhouette coefficients  ####
    if('Silhouette' %in% plots.table$Metrics & 'barPlot' %in% plots.table$PlotTypes){
        index <- plots.table$Metrics == 'Silhouette' & plots.table$PlotTypes == 'barPlot'
        sil.single.vars <- plots.table$Variables[index]
        for(i in sil.single.vars){
            se.obj <- plotSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = i,
                plot.type = 'single.plot',
                silhouette.method = 'sil.euclidian',
                plot.output = F,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### combined plot silhouette coefficients  ####
    if('Silhouette' %in% plots.table$Metrics & 'combinedPlot' %in% plots.table$PlotTypes){
        index <- plots.table$Metrics == 'Silhouette' & plots.table$PlotTypes == 'combinedPlot'
        sil.combined.vars <- plots.table$Variables[index]
        for(i in sil.combined.vars){
            se.obj <- plotSilhouette(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = strsplit(x = i, split = '&')[[1]],
                plot.type = 'combined.plot',
                silhouette.method = 'sil.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## ARI ####
    ### compute adjusted rand index ####
    if('ARI' %in% metrics.table$Metrics){
        index.single <- metrics.table$Metrics == 'ARI' &
            metrics.table$PlotTypes == 'barPlot'
        ari.single.vars <- metrics.table$Variables[index.single]
        index.combined <- metrics.table$Metrics == 'ARI' &
            metrics.table$PlotTypes == 'combinedPlot'
        ari.combined.vars <- metrics.table$Variables[index.combined]
        ari.combined.vars <- unlist(strsplit(x = ari.combined.vars, split = '&'))
        all.ari.vars <- unique(c(ari.single.vars, ari.combined.vars))
        for(i in all.ari.vars){
            se.obj <- computeARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                clustering.method = ari.clustering.method,
                hclust.method = ari.hclust.method,
                hclust.dist.measure = ari.hclust.dist.measure,
                fast.pca = fast.pca,
                nb.pcs = ari.nb.pcs,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### barplot adjusted rand index  ####
    if('ARI' %in% plots.table$Metrics & 'barPlot' %in% plots.table$PlotTypes){
        index <- plots.table$Metrics == 'ARI' & plots.table$PlotTypes == 'barPlot'
        ari.single.vars <- plots.table$Variables[index]
        for(i in ari.single.vars){
            se.obj <- plotARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = i,
                plot.type = 'single.plot',
                ari.method = 'hclust.complete.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    ### combined adjusted rand index  ####
    if('ARI' %in% plots.table$Metrics & 'combinedPlot' %in% plots.table$PlotTypes){
        index <- plots.table$Metrics == 'ARI' & plots.table$PlotTypes == 'combinedPlot'
        ari.combined.vars <- plots.table$Variables[index]
        for(i in ari.combined.vars){
            se.obj <- plotARI(
                se.obj = se.obj,
                assay.names = assay.names,
                variables = strsplit(x = i, split = '&')[[1]],
                plot.type = 'combined.plot',
                ari.method = 'hclust.complete.euclidian',
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ## Gene variable correlation ####
    ### compute gene variable correlations ####
    if('Correlation' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'Correlation'
        gene.var.corr.vars <- metrics.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- computeGenesVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                method = corr.method,
                a = a,
                rho = rho,
                plot.top.genes = FALSE,
                nb.top.genes = NULL,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                apply.round = TRUE,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE)
        }
    }
    ### plot gene variable correlations ####
    if('Correlation' %in% plots.table$Metrics){
        index <- plots.table$Metrics == 'Correlation'
        gene.var.corr.vars <- plots.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- plotGenesVariableCorrelation(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                correlation.method = corr.method,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
            }
    }

    ## Gene variable anova ####
    ### compute gene variable anova ####
    if('ANOVA' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'ANOVA'
        gene.var.anova.vars <- metrics.table$Variables[index]
        gene.var.anova.fvalue.scores <- list()
        gene.var.anova.pvalue.scores <- list()
        for(i in gene.var.anova.vars){
            se.obj <- computeGenesVariableAnova(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                method = anova.method,
                plot.top.genes = FALSE,
                nb.top.genes = NULL,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                apply.round = TRUE,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE)
        }
    }

    ### plot gene variable anova ####
    if('ANOVA' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'ANOVA'
        gene.var.corr.vars <- metrics.table$Variables[index]
        for(i in gene.var.corr.vars){
            se.obj <- plotGenesVariableAnova(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                anova.method = anova.method,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = TRUE)
        }
    }
    ## DGE ####
    ### compute dge ####
    if('DGE' %in% metrics.table$Metrics){
        index <- metrics.table$Metrics == 'DGE'
        dge.vars <- metrics.table$Variables[index]
        dge.scores <- list()
        dge.uniform.scores <- list()
        for(i in dge.vars){
            se.obj <- computeDGE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                apply.log = apply.log,
                pseudo.count = pseudo.count,
                assess.se.obj = FALSE,
                remove.na = 'none',
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }

    ### plot p-value hist ####
    if('DGE' %in% plots.table$Metrics){
        index <- plots.table$Metrics == 'DGE'
        dge.vars <- plots.table$Variables[index]
        for(i in dge.vars){
            se.obj <- plotDGE(
                se.obj = se.obj,
                assay.names = assay.names,
                variable = i,
                plot.ncol = deg.plot.ncol,
                plot.nrow = deg.plot.nrow,
                plot.output = FALSE,
                save.se.obj = TRUE,
                verbose = verbose)
        }
    }
    # Plot all the metrics ####
    mytheme <- gridExtra::ttheme_default(
        core = list(fg_params = list(cex = 1)),
        colhead = list(fg_params = list(cex = 1)),
        rowhead = list(fg_params = list(cex = 1)))

    categorical.vars <- continuous.vars <- NULL
    if (!is.null(variables)) {
        vars.class <- sapply(
            variables,
            function(x) class(colData(se.obj)[[x]]))
        categorical.vars <- names(vars.class[vars.class %in% c('character', 'factor')])
        continuous.vars <- names(vars.class[vars.class %in% c('numeric', 'integer')])
    }
    if(is.null(output.file.name)){
        output.file.name <- 'RUVIIIPRPS_VariationAssessment'
    }
    pdf(paste0(output.file.name, '.pdf'), width = 18, height = 10)
    plot.new()
    text(.5, .5, "Assess variation and normalization perfroance", font = 2, cex = 1.5)
    grid.table(metrics.table, theme = mytheme)

    if('General' %in% plots.table$Variables  & 'rlePlot' %in% plots.table$PlotTypes){
        print(se.obj@metadata$plot$RLE$uncolored.rle.plot)
    }
    for(i in continuous.vars){
        plot.new()
        text(.5, .5, paste0("Assess variation \n in the variable: \n ", i ), font = 2, cex = 1.5)
        metrics.table.var <- plots.table[plots.table$Variables == i, ]
        for(j in 1:nrow(metrics.table.var)){
            if(metrics.table.var$Factors[j] == 'rleMedians'){
                if(length(assay.names) > 1){
                    print(se.obj@metadata$plot$RLE$rle.var.plot[[i]]$rle.med.var.plot)
                } else print(se.obj@metadata$metric[[assay.names]]$RLE$rle.plot$rle.var.plot[[j]]$rle.med.var.plot)
            }
            if(metrics.table.var$Factors[j] == 'rleIqr'){
                if(length(assay.names) > 1){
                    print(se.obj@metadata$plot$RLE$rle.var.plot[[i]]$rle.iqr.var.plot)
                } else print(se.obj@metadata$metric[[assay.names]]$RLE$rle.plot$rle.var.plot[[j]]$rle.iqr.var.plot)
            }
            if(metrics.table.var$Factors[j] == 'pcs' & metrics.table.var$Metrics[j] == 'PCA'){
                if(length(assay.names) > 1){
                    print(se.obj@metadata$plot$PCA$fast.pca[[i]]$pca.var.scat.plot)
                } else print(se.obj@metadata$metric[[assay.names]]$PCA$fast.pca$pca.plot[[j]]$pca.var.scat.plot)
            }
            if(metrics.table.var$Factors[j] == 'pcs' & metrics.table.var$Metrics[j] == 'LRA'){
                if(length(assay.names) > 1){
                    print(se.obj@metadata$plot$LRA[[i]])
                } else print(se.obj@metadata$metric[[assay.names]]$LRA[[j]]$lra.plot)
            }
            if(metrics.table.var$Factors[j] == 'geneCorr'){
                if(length(assay.names) > 1){
                    print(se.obj@metadata$plot$Correlation$spearman[[i]])
                } else print(se.obj@metadata$metric[[assay.names]]$Correlation$spearman[[j]]$cor.coef.plot)
            }
        }
    }
    for(i in categorical.vars){
        plot.new()
        text(.5, .5, paste0("Assess variation \n in the variable: \n ", i ), font = 2, cex = 1.5)
        metrics.table.var <- plots.table[metrics.table$Variables == i, ]
        if('coloredRLEplot' %in% metrics.table.var$PlotTypes){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$RLE$colored.rle.plot[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$RLE$rle.plot$colored.rle.plot[[i]])

        }
        if('rleMedians' %in% metrics.table.var$Factors){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$RLE$rle.var.plot[[i]]$rle.med.var.plot)
            } else print(se.obj@metadata$metric[[assay.names]]$RLE$rle.plot$rle.var.plot[[i]]$rle.med.var.plot)

        }
        if('rleIqr' %in% metrics.table.var$Factors){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$RLE$rle.var.plot[[i]]$rle.iqr.var.plot)
            } else print(se.obj@metadata$metric[[assay.names]]$RLE$rle.plot$rle.var.plot[[i]]$rle.iqr.var.plot)
        }
        if('pcsboxPlot' %in% paste0(metrics.table.var$Factors, metrics.table.var$PlotTypes) ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$PCA$fast.pca[[i]]$pca.box.plot)
            } else print(se.obj@metadata$metric[[assay.names]]$PCA$fast.pca$pca.plot[[i]]$pca.box.plot)
        }
        if('pcsscatterPlot' %in% paste0(metrics.table.var$Factors, metrics.table.var$PlotTypes)){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$PCA$fast.pca[[i]]$pca.scat.plot)
            } else print(se.obj@metadata$metric[[assay.names]]$PCA$fast.pca$pca.plot[[i]]$pca.scat.plot)
        }
        if( 'VCA' %in% metrics.table.var$Metrics ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$VCA[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$VCA[[i]]$vect.corr.plot)
        }
        if('ARI' %in% metrics.table.var$Metrics ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$ARI$hclust.complete.euclidian$ari.single.plot[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$ARI$hclust.complete.euclidian[[i]]$ari.single.plot)
        }
        if('silhouetteCoeff' %in% metrics.table.var$Factors ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$Silhouette$sil.euclidian[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$Silhouette$sil.euclidian[[i]]$sil.coef.single.plot)
        }
        if('geneAnova' %in% metrics.table.var$Factors ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$ANOVA$aov[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$ANOVA$aov[[i]]$F.values.plot)
        }
        if('pvalue' %in% metrics.table.var$Factors ){
            if(length(assay.names) > 1){
                print(se.obj@metadata$plot$DEG[[i]])
            } else print(se.obj@metadata$metric[[assay.names]]$DGE[[i]]$p.values.plot)
        }
    }
    dev.off()
    printColoredMessage(message = '------------The assessVariation function finished.',
                        color = 'white',
                        verbose = verbose)
    return(se.obj)
}






